/**
 * 
 */
package util;

import java.io.IOException;
import java.io.Serializable;
import java.util.AbstractList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.RandomAccess;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * @author fuzho
 *
 */
public class Vector<E> extends AbstractList<E> 
    implements List<E>, RandomAccess, Cloneable, Serializable {

	/**
	 * generated by Eclipse
	 */
	private static final long serialVersionUID = -6990190414953663029L;
	
	private final static int DEFAULT_VECTOR_SIZE = 100;
	private final static int DEFAULT_INCRMENT = 10;
	
	protected Object[] ds;
	protected int numberOfElement;
	protected int incr;
	
	public Vector(int vsz ,int inc) {
		if (vsz < 0) throw new IllegalArgumentException("Illegal VectorSize : "+ vsz);
		if (inc < 0) throw new IllegalArgumentException("Illegal increment number : "+ inc);
		ds = new Object[vsz];
		incr = inc;
		numberOfElement = 0;
		modCount ++ ;
	}
	public Vector(int vsz) {
		this(vsz , DEFAULT_INCRMENT);
	}
	public Vector() {
		this(DEFAULT_VECTOR_SIZE);
	}
	public Vector(Collection<? extends E> c) {
		ds = c.toArray();
		numberOfElement = ds.length;
	}
	
	private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
	private void autoGrow(int i) {
		int oldSize = ds.length;
		int newSize = oldSize + ((incr == 0) ? oldSize : incr);
		if (newSize < i) newSize = i;
		if (newSize - MAX_ARRAY_SIZE > 0) newSize = MAX_ARRAY_SIZE;
		ds = Arrays.copyOf(ds, newSize);
		modCount ++;
	}
	private void arraySpaceTest(int i) {
		if (ds.length < i) autoGrow(i);
	}
	@SuppressWarnings("unchecked")
	@Override
	public E get(int index) {
		if (index >= numberOfElement) throw new ArrayIndexOutOfBoundsException("this element at index : ["+ index+"] is not exists ");
		return (E) ds[index];
	}
	
	@Override
	public E set(int index, E e) {
		E oldElement = get(index); // if you can get it, you must can set it.
		ds[index] = e;
		return oldElement;
	}
	@Override
	public boolean add(E e) {
		modCount++;
		arraySpaceTest(numberOfElement + 1);
		ds[numberOfElement++] = e;
		return true;
	}
	@Override
	public void add(int index, E element) {
		insertElementAt(index, element);
	}
	
	@Override
	public int size() {
		return numberOfElement;
	}
	public void clear() {
		removeAllElement();
	}
	@Override
	public boolean isEmpty() {
		return numberOfElement == 0;
	}
	
	public int vsz() {
		return ds.length;
	}
	
	public void copyToAnArray(Object[] array) {
		System.arraycopy(ds, 0, array, 0, numberOfElement);
	}
	public void dropUselessSpace() {
		if (ds.length > numberOfElement) {
			ds = Arrays.copyOf(ds, numberOfElement);
		}
		modCount++;
	}
	public void setSize(int s) {
		if (s > ds.length) {
			arraySpaceTest(s);
		} else {
			for (int i = s; i<numberOfElement;i++)
				ds[i] = null;
			numberOfElement = s;
		}
		modCount++;
	}
	public Enumeration<E> elements() {
		return elements(0);
	}
	public Enumeration<E> elements(int index) {
		return new Enumeration<E>() {
			
			int currPostion = index;
			@Override
			public boolean hasMoreElements() {
				return currPostion < numberOfElement;
			}

			@SuppressWarnings("unchecked")
			@Override
			public E nextElement() {
				return hasMoreElements() ? (E) ds[currPostion++] : null;
			}
		};
	}
	
	public int indexOf(Object o, int index) {
		if (o == null) {
			for (int i = index; i < numberOfElement; ++i)
				if (ds[i] == null) return i;
		} else {
			for (int i = index; i < numberOfElement; ++i)
				if (ds[i].equals(o)) return i;
		}
		return -1;
	}
	
	public int indexOf(Object o) {
		return indexOf(o, 0);
	}
	
	public boolean contains(Object o) {
		return (indexOf(o)!=-1);
	}
	
	public int lastIndexOf(Object o, int index) {
		if (index >= numberOfElement) throw new IndexOutOfBoundsException(index + " >= " 
																          + numberOfElement);
		if (o== null) {
			for (int i = index;i>=0;--i) {
				if (ds[i]==null)
					return i;
			} 
		}else {
			for (int i = index;i>=0;--i) {
				if (ds[i].equals(o))
					return i;
			} 
		}
		return -1;
	}
	
	public int lastIndexOf(Object o) {
		return lastIndexOf(o,numberOfElement - 1);
	}
	
	@SuppressWarnings("unchecked")
	public E elementAt(int index) {
		if (index >=  numberOfElement) throw new ArrayIndexOutOfBoundsException(index + " >= "
																				+ numberOfElement);
		return (E) ds[index];
	}
	
	public E firstElement() {
		if (numberOfElement == 0) throw new NoSuchElementException();
		return elementAt(0);
	}
	
	public E lastElement() {
		if (numberOfElement == 0) throw new NoSuchElementException();
		return elementAt(numberOfElement - 1); 
	}
	
	public void setElementAt(Object o,int index) {
		if (index >= numberOfElement) throw new ArrayIndexOutOfBoundsException(index + " >= "+
																			   numberOfElement);
		ds[index] = o;
	}
	
	public boolean removeElementAt(int index) {
		if (index >= numberOfElement) throw new ArrayIndexOutOfBoundsException(index + " >= "+
				   numberOfElement);
		if (index < 0) throw new ArrayIndexOutOfBoundsException(index + " < 0");
		int FragmentSize = numberOfElement - index - 1;
		
		if (FragmentSize > 0) System.arraycopy(ds, index + 1, ds, index, FragmentSize);
		numberOfElement --;
		ds[numberOfElement] = null; //尾部产生一个多余元素 等待GC回收
		return true;
	}
	private void insertElementAt(int index,Object obj) {
		if (index > numberOfElement) throw new ArrayIndexOutOfBoundsException(index);
		arraySpaceTest(numberOfElement + 1);
		System.arraycopy(ds, index, ds, index+1, numberOfElement-index);
		ds[index] = obj;
		numberOfElement ++;
		modCount ++;
	}
	public void insertElementAt(E o ,int index) {
		insertElementAt(index, o);
	}
	public void addElement(E o) {
		add(o);
	}
	public boolean addAllElement(Collection<? extends E>[] o) {
		int newSize = o.length + numberOfElement;
		arraySpaceTest(newSize);
		System.arraycopy(o, 0, ds, numberOfElement, o.length);
		numberOfElement += o.length;
		return o.length!=0;
	}
	public boolean removeFirstElement(Object o) {
		int index = indexOf(o);
		if (index != -1) {
			removeElementAt(index);
			modCount ++;
			return true;
		}
		modCount ++;
		return false;
	}
	
	public void removeAllElement() {
		for (int i = 0;i < numberOfElement; ++i) {
			ds[i] = null;
		}
		numberOfElement = 0;
		modCount ++;
	}
	@SuppressWarnings("unchecked")
	public Object clone() throws CloneNotSupportedException {
		Vector<E> o = new Vector<>(vsz(), incr);
		o = (Vector<E>) super.clone();
		o.ds = this.ds;
		o.modCount = 0;
		o.numberOfElement = this.numberOfElement;
		return o;
	}
	public synchronized boolean addAll(Collection<E> c,int index) {
        if (index < 0 || index > numberOfElement)
            throw new ArrayIndexOutOfBoundsException(index);
		Object[] newArray = c.toArray();
		int newSize = newArray.length + numberOfElement;
		arraySpaceTest(newSize);
		
		System.arraycopy(ds, index, ds, index+ newArray.length, numberOfElement - index); 
		System.arraycopy(newArray, 0, ds, index, newArray.length);
		
		modCount ++;
		return (newArray.length != 0);
	}
	public synchronized void removeRange(int fromIndex,int toIndex) {
		if (fromIndex > toIndex) throw new IllegalArgumentException("fromIndex:"+fromIndex+ " > " + "toIndex:" + toIndex);
		if (fromIndex < 0) throw new ArrayIndexOutOfBoundsException(fromIndex +" < 0");
		if (toIndex >= numberOfElement) new ArrayIndexOutOfBoundsException(toIndex +" >= "+ numberOfElement);
		
        int numMoved = numberOfElement - toIndex;
        System.arraycopy(ds, toIndex, ds, fromIndex,
                         numMoved);

        int newnumberOfElement = numberOfElement - (toIndex-fromIndex);
        while (numberOfElement != newnumberOfElement)
            ds[--numberOfElement] = null;
	}
	//code from java.util.Vector
	private void writeObject(java.io.ObjectOutputStream s) throws IOException {
		final java.io.ObjectOutputStream.PutField fields = s.putFields();
        final Object[] data;
        synchronized (this) {
            fields.put("capacityIncrement", incr);
            fields.put("elementCount", numberOfElement);
            data = ds.clone();
        }
        fields.put("elementData", data);
        s.writeFields();
	}
	
	public Object[] toArray() {
		return Arrays.copyOf(ds, numberOfElement);
	}
	public synchronized boolean containsAll(Collection<?> c) {
		return super.containsAll(c);
	}
	public synchronized boolean removeAll(Collection<?> c) {
		return super.removeAll(c);
	}
	public synchronized boolean retainAll(Collection<?> c) {
		return super.retainAll(c);
	}
	
	public boolean equals(Object o) {
		return super.equals(o);
	}
	public int hashCode() {
		return super.hashCode();
	}
	public String toString() {
		return super.toString();
	}
	
	private class Itr implements Iterator<E> {

		int cursor = 0;
		int lstRet = -1;
		int expectedModCount = modCount;
		@Override
		public boolean hasNext() {
			return cursor != numberOfElement;
		}

		@SuppressWarnings("unchecked")
		@Override
		public E next() {
			checkHasMod();
			if (cursor >= numberOfElement) throw new NoSuchElementException();
			lstRet = cursor++;
			return (E) ds[lstRet];
		}
		
		public void remove() {
            if (lstRet == -1)
                throw new IllegalStateException();
            synchronized (Vector.this) {
    			checkHasMod();
                Vector.this.remove(lstRet);
                expectedModCount = modCount;
            }
            cursor = lstRet;
            lstRet = -1;
		}
		@SuppressWarnings({ "unchecked" })
		public void forEachReminding(Consumer<? super E> action) {
			Objects.requireNonNull(action);
			synchronized (Vector.this) {
				final int size = numberOfElement;
				if (cursor >= size) {
					return;
				}
				int i = cursor;
				while (modCount==expectedModCount&&i!=size) {
					action.accept((E) ds[i++]);
				}
                cursor = i;
                lstRet = i - 1;
                checkHasMod();
			}
		}
		boolean checkHasMod() {
			return modCount != expectedModCount;
		}
	}
	
    final class ListItr extends Itr implements ListIterator<E> {
        ListItr(int index) {
            super();
            cursor = index;
        }
        
		@Override
		public boolean hasPrevious() {
			return cursor != 0;
		}
		

		@SuppressWarnings("unchecked")
		@Override
		public E previous() {
			synchronized (Vector.this) {
                checkHasMod();
                int i = cursor - 1;
                if (i < 0)
                    throw new NoSuchElementException();
                cursor = i;
                return (E) ds[lstRet = i];
            }
		}

		@Override
		public int nextIndex() {
			return cursor;
		}

		@Override
		public int previousIndex() {
			if (cursor == 0) throw new NoSuchElementException();
			return cursor - 1;
		}

		@Override
		public void set(E e) {
            if (lstRet == -1)
                throw new IllegalStateException();
            synchronized (Vector.this) {
                checkHasMod();
                Vector.this.set(lstRet, e);
            }
		}

		@Override
		public void add(E e) {
            int i = cursor;
            synchronized (Vector.this) {
                checkHasMod();
                Vector.this.add(i, e);
                expectedModCount = modCount;
            }
            cursor = i + 1;
            lstRet = -1;
		}
		
	}
    
    public synchronized Iterator<E> iterator() {
        return new Itr();
    }
    public synchronized ListIterator<E> listIterator() {
    	return new ListItr(0);
    }
    
    @SuppressWarnings("unchecked")
	@Override
    public void forEach(Consumer<? super E> action) {
    	Objects.requireNonNull(action);
    	
    	for (int i = 0;i < numberOfElement; ++i)
    		action.accept((E) ds[i]);
    	
    }
    
    @SuppressWarnings("unchecked")
	public boolean removeIf(Predicate<? super E> filter) {
    	boolean isSomeElemRemoved = false;
    	
    	for (int i = 0;i < numberOfElement; ++i)
    		if (filter.test((E) ds[i])) {
    			remove(i); //TODO:这样做太过于费时，应该把待删元素提交给一个待删集合，然后批量操作待删元素
    			i --;
    		}
    	
    	return isSomeElemRemoved;
    }

	@SuppressWarnings("unchecked")
    public E[] takeIf(Predicate<? super E> filter) {
		E[] d = (E[]) new Object[ds.length]; //最坏情况:filter是永真表达式
		int okCaseCount = 0;
    	for (int i = 0;i < numberOfElement; ++i)
    		if (filter.test((E) ds[i])) {
    			d[okCaseCount++] = (E) ds[i];
    		}
    	return d;
    }
    @SuppressWarnings("unchecked")
	public void sort(Comparator<? super E> c) {
        Arrays.sort((E[]) ds, 0, numberOfElement, c);
    }
    @SuppressWarnings("unchecked")
	public void sort() {
    	sort(new DefaultComparator());
    }
    @SuppressWarnings("rawtypes")
	class DefaultComparator implements Comparator {

		@Override
		public int compare(Object o1, Object o2) {
			return o1.hashCode() - o2.hashCode();
		}
    	
    }
    //TODO:: Spliterator
}
